# piptm23.12

### 1.
В JavaScript существуют следующие типы данных:
1. Примитивные типы данных:
   - Число (number): целые числа и числа с плавающей точкой.
   - Строка (string): последовательность символов.
   - Булев тип (boolean): true (истина) или false (ложь).
   - undefined: значение переменной, которой не было присвоено значение.
   - null: отсутствие значения.
   - Symbol: уникальное и неизменяемое значение.
2. Структурные типы данных:
   - Объект (object): коллекция свойств.
   - Массив (array): упорядоченная коллекция элементов.
   - Функция (function): блок кода, который может быть вызван.
   - Регулярное выражение (regular expression): шаблон для поиска и сопоставления строк.
   - Класс (class): шаблон для создания объектов с определенными свойствами и методами.

Разница между let, const и var при объявлении переменных:
- let: переменная, объявленная с использованием let, имеет блочную область видимости (ее можно использовать только внутри блока, в котором она объявлена), и ее значение может быть переназначено.
- const: переменная, объявленная с использованием const, также имеет блочную область видимости, но ей нельзя присвоить новое значение после ее инициализации. Однако, если это объект или массив, то его свойства или элементы могут быть изменены.
- var: переменная, объявленная с использованием var, имеет функциональную область видимости (ее можно использовать внутри функции, в которой она объявлена), и ее значение может быть переназначено. В отличие от let и const, использование var позволяет переменной быть поднятой (hoisted), что означает, что она может быть использована до ее фактического объявления.

Hoisting (поднятие) - это механизм в JavaScript, при котором объявления переменных и функций перемещаются в начало своей области видимости перед выполнением кода. Это означает, что переменные и функции могут быть использованы до их фактического объявления. Однако, только объявления поднимаются, а не их инициализации.

### 2
1. Объявление функции в JavaScript может быть выполнено двумя способами: с помощью объявления функции (function declaration) и с помощью выражения функции (function expression).

Пример объявления функции:
```
function имяФункции(параметры) {
  // код функции
}
```

Пример выражения функции:
```
var имяФункции = function(параметры) {
  // код функции
};
```

2. Разница между объявлением функции и выражением функции заключается в том, когда они создаются и становятся доступными для использования.

При объявлении функции (function declaration) весь блок функции «всплывает» в начале области видимости (это называется hoisting), поэтому функцию можно вызвать до её фактического объявления в коде.

При выражении функции (function expression) создается переменная, содержащая ссылку на функцию. В этом случае переменная также существует до вызова функции, но сама функция может быть вызвана только после её объявления в коде.

3. Стрелочные функции - это новый синтаксис объявления функций в JavaScript, добавленный в стандарте ECMAScript 6. Они предоставляют более краткую и удобную запись функций.

Синтаксис стрелочной функции:
```
(параметры) => {
  // код функции
}
```

Стрелочные функции имеют некоторые отличительные особенности:
- Они всегда анонимны и не могут быть использованы с помощью ключевого слова "function".
- Если функция принимает только один параметр, круглые скобки можно опустить.
- Если блок функции состоит только из одной инструкции, фигурные скобки и оператор return можно опустить. В этом случае функция возвращает значение этой инструкции.
- Контекст выполнения (значение this) внутри стрелочной функции отличается от контекста выполнения обычной функции. В стрелочных функциях значение this сохраняется таким же, какое было на момент их создания, и не может быть изменено с помощью методов call(), apply() и bind().

Примеры стрелочных функций:
```
const sum = (a, b) => a + b;

const multiplyByTwo = num => num * 2;

const sayHello = () => console.log('Hello');
```

### 3
1. Чтобы создать объект в JavaScript, вы можете использовать следующий синтаксис:

```javascript
var объект = {};
```

или

```javascript
var объект = new Object();
```

Вы также можете добавить свойства и методы к созданному объекту путем присваивания им значений или функций. Например:

```javascript
var объект = {
  свойство: значение,
  метод: функция() {
    // код метода
  }
};
```

2. Чтобы добавить новый элемент в конец массива, вы можете использовать метод `push()`. Например:

```javascript
var массив = [1, 2, 3];
массив.push(4);
console.log(массив); // [1, 2, 3, 4]
```

3. Чтобы перебрать все элементы массива, можно использовать цикл `for` или метод `forEach()`. Например:

С использованием цикла `for`:

```javascript
var массив = [1, 2, 3];
for (var i = 0; i < массив.length; i++) {
  console.log(массив[i]);
}
```

С использованием метода `forEach()`:

```javascript
var массив = [1, 2, 3];
массив.forEach(function (элемент) {
  console.log(элемент);
});
```

### 4
1. Для назначения обработчика события элементу можно использовать метод `addEventListener` объекта элемента. Пример использования:

```javascript
const button = document.querySelector('button');
button.addEventListener('click', () => {
  console.log('Кнопка была нажата');
});
```

2. Event delegation (делегирование событий) - это техника обработки событий, в которой обработчик события назначается на родительский элемент, но событие обрабатывается, когда оно происходит на одном из его потомков. Это позволяет иметь только один обработчик для группы элементов, что может быть полезным при динамическом добавлении или удалении элементов. Пример использования:

```html
<ul id="todo-list">
  <li>Задача 1</li>
  <li>Задача 2</li>
  <li>Задача 3</li>
</ul>
```

```javascript
const todoList = document.getElementById('todo-list');
todoList.addEventListener('click', (event) => {
  if (event.target.tagName === 'LI') {
    console.log('Задача была кликнута');
  }
});
```

3. Для отмены стандартного поведения события можно использовать метод `preventDefault()` объекта события. Пример использования:

```javascript
const link = document.querySelector('a');
link.addEventListener('click', (event) => {
  event.preventDefault();
  console.log('По клику на ссылку было отменено перенаправление');
});
```

### 5
Синхронный код в JavaScript работает последовательно: каждая задача будет выполняться только после завершения предыдущей. Это означает, что код будет блокировать выполнение других задач до тех пор, пока не завершится текущая задача.

Асинхронный код в JavaScript, с другой стороны, не блокирует выполнение других задач. Вместо этого, он использует callbacks или Promises для управления асинхронными операциями. Асинхронный код позволяет выполнять несколько задач одновременно и продолжать работу с остальным кодом без ожидания завершения асинхронной операции.

Promise в JavaScript представляет собой объект, который представляет завершение или ошибку асинхронной операции и возвращает результат этой операции в будущем. Promise может быть в трех состояниях: pending (ожидание), fulfilled (выполнено) и rejected (отклонено). 

Async/await - это синтаксический сахар над Promise, позволяющий писать асинхронный код так, как будто он синхронный. Асинхронные операции могут быть обернуты в функцию с ключевым словом async. Внутри такой функции можно использовать ключевое слово await для ожидания завершения асинхронной операции и получения результата. Функция с ключевым словом async всегда возвращает Promise, который разрешается с результатом возвращаемым операцией, включая неявные возвращаемые значения. Чтобы использовать async/await, нужно вызывать асинхронные функции с помощью ключевого слова await. Это позволяет писать асинхронный код так, будто он синхронный, что может сделать код более понятным и поддерживаемым.